# -*- coding: utf-8 -*-
"""MAPCalculation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CAbLXdn_WNt2iX873YvIravTNHJIh-6O
"""

!sudo wget -O /usr/sbin/gdrivedl 'https://f.mjh.nz/gdrivedl'
!sudo chmod +x /usr/sbin/gdrivedl

!gdrivedl "https://drive.google.com/file/d/1_5ITiJMIPNdANgGm34vLSMT4F8DF6NJM/view?usp=sharing"

!unzip "/content/Data.zip" -d "/content/Data"

import numpy as np
from numpy import asarray
import os
import tensorflow.keras
from tensorflow.keras.preprocessing import image
from keras.applications.vgg16 import VGG16
from tensorflow.keras.applications.vgg16 import preprocess_input
import sys
from google.colab.patches import cv2_imshow
import cv2
from PIL import Image
import csv

def extract_feature(img_dir, based_model):
  img = image.load_img(img_dir, target_size=(224, 224))
  img_arr = image.img_to_array(img)
  img_arr = np.expand_dims(img_arr,axis=0)
  img_arr = preprocess_input(img_arr)
  feature = based_model.predict(img_arr)
  arr = asarray(feature.flatten())
  return arr

def Image_extraction(Path, based_model, extract_feature):
  imgs = os.listdir(Path)
  Extraction = []
  for i in imgs:
    if i != 'desktop.ini' and i != '.ipynb_checkpoints':
      img_path = os.path.join(Path,i)
      feature = extract_feature(img_path,based_model)
      Extraction.append([i,feature])
  return Extraction

#Retrieve ONE image
def System(data_path, Query_path, nb_img, Cal):
  based_model = VGG16(include_top=False)
  #Extract feature from data 100 image and Query
  Feature_Extraction = Image_extraction(data_path, based_model, extract_feature)
  Query = extract_feature(Query_path, based_model)
  #Calculate the distance
  Distance = []
  for i in range(len(Feature_Extraction)):
    Dis = Cal(Feature_Extraction[i][1], Query)
    Ele = [Dis,Feature_Extraction[i][0]]
    Distance.append(Ele)
  Q = cv2.imread(Query_path)
  cv2_imshow(Q)
  print('\n')
  print('\n')
  print('========================================IMAGE RETRIVAL============================================')
  print('\n')
  print('\n')
  Distance.sort(reverse=True)
  for k in range(int(nb_img)):
    img_query_path = os.path.join(data_path, str(Distance[k][1]))
    image = cv2.imread(img_query_path) 
    cv2_imshow(image)
    print('*************************************')
  cv2.waitKey()
  cv2.destroyAllWindows()

#Retrieve more than one image --> the results will be saved in file .txt
def System_Greater(data_path, Query_path, Cal, fol_name):
  based_model = VGG16(include_top=False)
  #Extract feature from data 100 image and Query
  Feature_Extraction = Image_extraction(data_path, based_model, extract_feature)
  Query = Image_extraction(Query_path, based_model, extract_feature)
  for j in range(len(os.listdir(Query_path))):
    file_name ='/content/' + fol_name + '/' + fol_name + '_Distance_' + Query[j][0].split('.jpg')[0] +'.csv'
    with open(file_name, 'w', encoding = 'utf-8') as f:
      writer = csv.writer(f, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
      Distance = []
      writer.writerow(['Distance', 'Image_name', 'Relevant'])
      for i in range(len(Feature_Extraction)):
        Dis = Cal(Feature_Extraction[i][1],Query[j][1])
        Ele = [Dis,Feature_Extraction[i][0]]
        Distance.append(Ele)
      print('Query: ' + str(Query[j][0]))
      Distance.sort(reverse=True)
      for i in range(len(Distance)):
        Re = Distance[i][1].split('_')
        if Re[0] == Query[j][0].split('.jpg')[0]:
          writer.writerow([Distance[i][0],Distance[i][1],1])
        else: 
          writer.writerow([Distance[i][0],Distance[i][1],0])

!mkdir '/content/Cosine/'
!mkdir '/content/Scala/'
!mkdir '/content/L1/'
!mkdir '/content/L2/'

def Cosine(x, y):
    return np.dot(x, y) / (np.sqrt(np.dot(x, x)) * np.sqrt(np.dot(y, y)))
def Scala(x,y):
  return np.dot(x, y)
def L1(x,y):
  return np.sum(np.abs(x-y))
def L2(x,y):
  return np.linalg.norm(x-y)

data_path = '/content/Data/100_Image'
Query_path = '/content/Data/Query'
F = 'Cosine'
System_Greater(data_path, Query_path, Cosine , F)
#System(data_path, Query_path, 4, Cosine)

"""#MAP Calculation"""

import pandas as pd
Path = '/content'
Category = ['Cosine', 'Scala', 'L1', 'L2']
Query = ['Dessert', 'Meat', 'Noodles', 'Seafood', 'Vegetable', 'Bundau', 'Coffee', 'Cream', 'Thitkho']
i = 0
print('***********************************')
for cate in Category:
  AP = []
  folder = os.path.join(Path,cate)
  for q in Query:
    file_name = cate + '_Distance_' + q + '.csv'
    file = pd.read_csv(os.path.join(folder,file_name), error_bad_lines=False)
    P = 0
    x,y = [],[]
    for i in range(len(file['Relevant'])):
      if file['Relevant'][i] == 1:
        P = P + (np.sum(file['Relevant'][:i+1])/(i+1))
    print(q,round(P/6,3))
    AP.append(P/6)
  print('***********************************')
  print('MAP_' + cate + ': ', round(np.average(AP),3))
  print('***********************************')

!zip -r 'Cosine.zip' '/content/Cosine'
!zip -r 'Scala.zip' '/content/Scala'
!zip -r 'L1.zip' '/content/L1'
!zip -r 'L2.zip' '/content/L2'

from google.colab import files
files.download("/content/Cosine.zip")
files.download("/content/Scala.zip")
files.download("/content/L1.zip")
files.download("/content/L2.zip")

data_path = '/content/Data/100_Image'
Query_path = '/content/Data/Query/Noodles.jpg'
F = 'Cosine'
#System_Greater(data_path, Query_path, Cosine , F)
System(data_path, Query_path, 4, Cosine)